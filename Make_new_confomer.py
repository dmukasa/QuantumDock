import numpy as np
from scipy.spatial.transform import Rotation as R
import sys
import subprocess as sp
import re

def Rename_PDB(Molecule_PATH):
    #Open the molecule file and turn it into lines
    file1 = open(Molecule_PATH, 'r')
    Lines = file1.readlines()
    
    Molecule_name = Molecule_PATH[Molecule_PATH.rindex('/')+1:][:-4]
        
    #The first two lines are notes on the file generation so skip these
    #Find the number of atoms in the system. This is in the master 
    #line, second to last word in the second to last line
    Num_atoms = int(Lines[-2].split()[-2])
    
    #The 4th word in the block from 3-Num_atoms is the molecule name
    #Replace this with the input Molecule name
    for i in range(2, 2 + Num_atoms):
        words = Lines[i].split()
        Current_name = words[4-1]
        
        Lines[i] = Lines[i].replace(Current_name, Molecule_name[:3]) #HERE IS THE TEST CHANGE
        
    #The atom type may not jsut be atom so go ahead and change this too
    for i in range(2, 2 + Num_atoms):
        words = Lines[i].split()
        atom_type = words[0]
        if atom_type != "ATOM":
            Lines[i] = Lines[i].replace(atom_type, "ATOM" + (len(atom_type)-4)*" ")
        
        
    #Return the lines back
    return Lines



def Make_Confomer(Molecule_A_Lines, Molecule_B_Lines):
    Molecule_A_name = Molecule_A_Lines[2][17:20]
    Molecule_B_name = Molecule_B_Lines[2][17:20]

    #The first two lines are comments we will leave blank
    New_lines = ["COMPND    " + "NAME A" + " + " + "NAME B FIX THIS" + "\n", "AUTHOR    GENERATED BY Daniel Mukasa\n"]
    
    #Now find the number of atoms in each molecule. This is 
    #in the master line, second to last word in the second to last line
    Num_A_atoms = int(Molecule_A_Lines[-2].split()[-2])
    Num_B_atoms = int(Molecule_B_Lines[-2].split()[-2])
    Total_atoms = Num_A_atoms + Num_B_atoms
    
    #The atom type may be ATOM, HETATM, etc. We want to make sure it is just ATOM
    for i in range(2,Num_A_atoms+2):
        #Find the first word the coordniates block (HETATM, ATOM, etc.)
        first_word_A = Molecule_A_Lines[i].split()[0]
        #Replace the first word with ATOM and paste in the rest of the line
        New_lines += ["ATOM     " + Molecule_A_Lines[i][9:]]
    for i in range(2,Num_B_atoms+2):
        #Find the first word the coordniates block (HETATM, ATOM, etc.)
        first_word_B = Molecule_B_Lines[i].split()[0]
        #Replace the first word with ATOM and paste in the rest of the line
        New_lines += ["ATOM     " + Molecule_B_Lines[i][9:]]
        

    #The atoms from the molecule B block are misnumbered. We need
    #to go back now and relabel them to count up to the total atom count
    for i in range(Num_A_atoms + 2, Num_A_atoms +  Num_B_atoms + 2): #Loop through indicies of block B
        #Replace the atom number with the correct integer (i.e. i-1)
        Current_atomic_number = i-1-Num_A_atoms
        Correct_number = i-1
        
        if Current_atomic_number < 10:
            New_lines[i] = New_lines[i].replace(" " + str(i-1-Num_A_atoms),str(i-1), 1)
        elif Current_atomic_number >= 10:
            New_lines[i] = New_lines[i].replace(str(i-1-Num_A_atoms),str(i-1), 1)

    
    #Now append the CONECT Blocks to the file
    New_lines += Molecule_A_Lines[Num_A_atoms+2:-2]
    New_lines += Molecule_B_Lines[Num_B_atoms+2:-2]
    
    #The atoms in the Molecule B connect block are mislabeled and should
    #be reindexed as i-1-Num_A_atoms -> i-1 in the range above
    
    #Loop through indicies of CONNECT block B
    for i in range(2 * Num_A_atoms +  Num_B_atoms + 2, 2*(Num_A_atoms +  Num_B_atoms + 1)): 
        CONECT_line_split = New_lines[i].split()[1:]
        num_atoms = len(CONECT_line_split)
        for j in range(num_atoms):
            if int(CONECT_line_split[j]) < 10:
                New_lines[i] = New_lines[i].replace(" " + CONECT_line_split[j] + " ", str(Num_A_atoms + int(CONECT_line_split[j])) + " ", 1)
            elif int(CONECT_line_split[j]) >= 10:
                New_lines[i] = New_lines[i].replace(CONECT_line_split[j] + " ", str(Num_A_atoms + int(CONECT_line_split[j])) + " ", 1)
    
    #Edit the MASTER line to accomidate the new number of atoms in
    #the system
    Master = Molecule_A_Lines[-2]
    Master = Master.replace(str(Num_A_atoms), str(Total_atoms))# + " \n"
    Master = [Master]
    
    New_lines += Master #SOMETHINGS WRONG HERE
    
    #Now wrap up with an end statement
    New_lines += ["END\n"]
    
    ###PDB file is incorecly formated if Num_A_atoms < 10, check for this 
    if range(Num_A_atoms+1,10):
        problem_numbers = range(Num_A_atoms+1,10)
        
        for num in problem_numbers:
            #loop through the New_lines
            for i in range(len(New_lines)):
                #Check if line has " " + num + " "
                if " " + str(num) + " " in New_lines[i]:
                    #Find the index of the first " " + num + " " instance
                    index = New_lines[i].find(str(num))
                    #If the like has a " " + num + " " then set line = line[:index] + " " + line[index:]
                    New_lines[i] = New_lines[i][:index] + " " + str(num) + New_lines[i][index+1:]


    #Return the confomer pdb lines
    return New_lines

def read_Coordinates(Lines, only_CA = True):
    #updated coords from a lines variable
    for line in Lines:
        if only_CA == True :
            if line.startswith('ATOM') and line[13:15] == 'CA': 
                try:    # matrix fill-up
                    CoordAtoms = np.vstack([CoordAtoms, [float(line[30:38]), float(line[38:46]), float(line[46:54])]]) # np.append
                except NameError:  # matrix declaration
                    CoordAtoms = np.array([[line[30:38],line[38:46], line[46:54]]], float) 
        else : 
            if line.startswith('ATOM'):
                try:    # matrix fill-up
                    CoordAtoms = np.vstack([CoordAtoms, [float(line[30:38]), float(line[38:46]), float(line[46:54])]]) # np.append
                except NameError:  # matrix declaration
                    CoordAtoms = np.array([[line[30:38],line[38:46], line[46:54]]], float)              
    return CoordAtoms

def Make_new_confomer(Molecule_1_PATH, Molecule_2_PATH, OUT_PATH):
    """This function will take two pdb files and make a joint pdb
    where the second molecule ill be randomly translated and rotated
    about the first"""
    #Suppress pringing information for formatting
    np.set_printoptions(suppress=True)
    
    #The filename should be #MOLECULE.pdb so this can be found in the path
    Molecule_1_name = Molecule_1_PATH[Molecule_1_PATH.rindex('/')+1:][:-4]
    Molecule_2_name = Molecule_2_PATH[Molecule_2_PATH.rindex('/')+1:][:-4]
    Confomer_name = Molecule_1_name + "_" + Molecule_2_name
    
    #Rename the pbd files and have the come out as lines
    
    #Make Lines lists for all the 
    Molecule_1_Lines = Rename_PDB(Molecule_1_PATH)
    Molecule_2_Lines = Rename_PDB(Molecule_2_PATH)
    Confomer_Lines = Make_Confomer(Molecule_1_Lines, Molecule_2_Lines)
    
    #Turn the Lines variables into numpy coordinates blocks
    Molecule_1_coords = read_Coordinates(Molecule_1_Lines, only_CA =  False)
    Molecule_2_coords = read_Coordinates(Molecule_2_Lines, only_CA =  False)
    
    #assume the input will be the coordinate block of the second molecules 
    Molecule = Molecule_2_coords

    #Translate the cordinates of this molecule along a random direction by 10 angstroms
    Rand_vect = np.random.rand(3) - 0.5 #random vector

    Rand_vect = 10 * Rand_vect/np.linalg.norm(Rand_vect) #normalize the vector and make it length 10

    Molecule = Molecule + Rand_vect #Translate the molecule along this vector 

    #Now Rotate the molecule 
    #Define the rotation operations
    R_x = R.from_euler('z', np.random.rand() * 360, degrees=True)
    R_y = R.from_euler('y', np.random.rand() * 360, degrees=True)
    R_z = R.from_euler('z', np.random.rand() * 360, degrees=True)

    #Apply them sequentially to each atom in the geometry
    Molecule = R_x.apply(Molecule)
    Molecule = R_y.apply(Molecule)
    Molecule = R_z.apply(Molecule)
    
    #Find the minimum distance between the two molecules
    distance_array = np.zeros((len(Molecule), len(Molecule_1_coords)))
    for i in range(len(Molecule)):
        for j in range(len(Molecule_1_coords)):
            distance_array[i,j] = np.linalg.norm(Molecule[i] - Molecule_1_coords[j])
    min_distance = np.min(distance_array)
    
    #Find the vector that defined this minimum distance
    min_index = np.where(distance_array == np.min(distance_array))
    min_vect = Molecule[min_index[0][0]] - Molecule_1_coords[min_index[1][0]]
    min_vect = min_vect/np.linalg.norm(min_vect) #normalize it
    
    #Decrease the separation between the two molecules along min_vect
    #such that they are separated by 1.8 A
    Molecule -= (min_distance-1.8)*min_vect#/step #Move the molecule

    #Round to avoid formating errors
    np.set_printoptions(formatter={'float': lambda x: "{0:0.3f}".format(x)})
    Molecule = np.round(Molecule, 3)
    [",".join(item) for item in Molecule.astype(str)]


    #Now re-enter this array into a pdb file 
    Molecule_1_Lines = Rename_PDB(Molecule_1_PATH)
    Confomer_Lines = Make_Confomer(Molecule_1_Lines, Molecule_2_Lines)
    
    num_1_atoms = len(Molecule_1_coords)
    num_2_atoms = len(Molecule_2_coords)

    for i in range(2 + num_1_atoms, 2 + num_1_atoms + num_2_atoms):
        New_Confomer_Lines = Confomer_Lines[i][:32] + str(Molecule[i - (2 + num_1_atoms)][0]) + " "*(6-len(str(Molecule[i - (2 + num_1_atoms)][0])))
        New_Confomer_Lines += "  " + str(Molecule[i - (2 + num_1_atoms)][1]) + " "*(6-len(str(Molecule[i - (2 + num_1_atoms)][1])))
        New_Confomer_Lines += "  " + str(Molecule[i - (2 + num_1_atoms)][2]) + " "*(6-len(str(Molecule[i - (2 + num_1_atoms)][2])))
        New_Confomer_Lines += Confomer_Lines[i][54:]
        Confomer_Lines[i] = New_Confomer_Lines
    
    #Save the file in the OUT_PATH
    f = open(OUT_PATH + "/" + Confomer_name + ".pdb", "w")
    f.writelines(Confomer_Lines)
    f.close()

Make_new_confomer(sys.argv[1], sys.argv[2], sys.argv[3])
